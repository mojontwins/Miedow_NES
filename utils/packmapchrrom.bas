' Packmapchrrom v0.2 20171110
' Creates a packed map plus decorations ready to be written to CHR ROM.
' Copyleft 2017 by The Mojon Twins

#include "cmdlineparser.bi"
#include "mtparser.bi"

Dim Shared As uByte mainBin (8191)
Dim Shared As Integer binIndex

Dim Shared As uByte partialBin (8191)
Dim Shared As Integer partialBinIndex

Sub resetBin ()
	binIndex = 0
End Sub

Sub writeToBin (v as uByte)
	mainBin (binIndex) = v
	If binIndex < 8191 Then binIndex = binIndex + 1
End Sub

Sub writeBin (f As Integer)
	Dim As Integer i
	Dim As uByte d
	d = 0

	For i = 0 To 8191
		If i < binIndex Then
			Put #f, , mainBin (i)
		Else
			Put #f, , d
		End If
	Next i
End Sub

Sub resetPartialBin ()
	partialBinIndex = 0
End Sub

Sub writeToPartialBin (v As uByte)
	partialBin (partialBinIndex) = v
	If partialBinIndex < 8191 Then partialBinIndex = partialBinIndex + 1
End Sub

Sub copyPartialBinToMainBin ()
	Dim As Integer i
	Print "Copying " & partialBinIndex & " bytes to main bin @ " & binIndex
	For i = 0 To partialBinIndex - 1
		writeToBin partialBin (i)
	Next i
End Sub

Sub usage
	Print "usage: "
	Print ""
	Print "packmapchrrom in=list.txt bin=chr.bin out=map.h [fixmappy]"
	Print "              in is the input filename. A list of .map in text format."
	Print "              bin is the binary file to be loaded to CHR-ROM"
	Print "              out is the output filename."
	Print "              fixmappy will substract 1 from every byte read"
	Print ""
	Print "list file format: Each line must look like this:"
	Print ""
	Print "filename.map,w,h,l0[-...]"
	Print ""
	Print "Where filename.map is the map filename, and w and h are each map's size"
	Print "lX are lock tile #s, '-' separated."
End Sub

Dim As String mandatory (2) = { "in", "bin", "out" }
Dim As Integer coords (31), mapW, mapH, scrW, scrH, nPant, maxPants, mapWtiles, fixMappy, realPant, nMap
Dim As Integer fIn, fOut, fBin, fListIn, xP, yP, x, y, i, j, first, tLock, locksI, n, cMapI, ctr, totalBytes, t0, lockssize, screensum
Dim As uByte BigMap (127, 255)
Dim As uByte cMap (127, 255), scrSizes (127)
Dim As String*384 cMapAmalgam (127)
Dim As uByte locks (63)
Dim As uByte d, dp, layer
Dim As uByte scrMaps (127)
Dim As String mapFile
Dim As Integer tlocks (31), tlocksIndex
DIm As String tlocksString

' decos
Dim As Integer decosAre, decosize
Dim As uByte decoT, decoCT
Dim As uByte decos (127, 127), decosYX (127, 127), YX (127), decosO (127, 127), decosI (127), decosOI (127)
Dim As Integer decosOffs (127)

' CHR ROM
Dim As uByte chrRom 
Dim As uInteger lBase

Print "packmapchrrom v0.2 20171110"

sclpParseAttrs
If Not sclpCheck (mandatory ()) Then usage: End

fixMappy = (sclpGetValue ("fixmappy") <> ""): If fixMappy Then Print "[fixmappy] ";

fListIn = FreeFile
Open sclpGetValue ("in") For Input As #fListIn

fOut = FreeFile
Open sclpGetValue ("out") For Output As #fOut

Print #fOut, "// CHR-ROM Map & decos indexes"
Print #fOut, "// Generated by packmapchrrom.exe v0.2 20171110"
Print #fOut, "// Copyleft 2017 by The Mojon Twins"

Print #fOut, ""

lBase = 0
chrRom = 1
scrW = 16: scrH = 12
nMap = 0

resetBin

While Not Eof (fListIn) 

	Input #fListIn, mapFile
	Input #fListIn, mapW
	Input #fListIn, mapH
	Input #fListIn, tlocksString

	parseCoordinatesStringCustom tlocksString, "-", coords ()
	tlocksIndex = 0
	While (coords (tlocksIndex) > 0)
		tlocks (tlocksIndex) = coords (tlocksIndex)
		tlocksIndex = tlocksIndex + 1
	Wend

	maxPants = mapW * mapH
	Print "Processing " & mapFile & " (" & mapW & "x" & mapH & ") ~ ";

	Print #fOut, "// Map # " & nMap & " read from " & mapFile & " (" & mapW & "x" & mapH & ")"
	Print #fOut, ""
	
	Print "Reading ~ ";

	fIn = FreeFile
	Open mapFile For Binary As #fIn

	For i = 0 To 127
		decosI (i) = 0
		decosOI (i) = 0
	Next i

	i = 0: dp = 0
	locksI = 0
	decosAre = 0

	While Not Eof (fIn)
		Get #fIn, , d

		xP = (i \ scrW) Mod mapW
		yP = i \ (scrW * scrH * mapW)

		x = i Mod scrW
		y = (i \ (mapW * scrW)) Mod scrH

		nPant = xP + yP * mapW

		i = i + 1

		For j = 0 To tlocksIndex - 1
			If d = tlocks (j) Then
				locks (locksI) = nPant: locksI = locksI + 1
				locks (locksI) = (y Shl 4) Or x: locksI = locksI + 1
			End If
		Next j
	
		If d > 15 Then
			' deco
			If Not decosAre Then 
				Print "Found T(s) OOR ";
				If sclpGetValue ("nodecos") <> "" Then Print "(ignored)" Else Print "(decos)"
				decosAre = -1
			End If			
			' Write to decos
			decosYX (nPant, decosI (nPant)) = y * 16 + x
			decos (nPant, decosI (nPant)) = d
			decosI (nPant) = decosI (nPant) + 1
			' Reset to previous (so there's more repetitions)
			d = dp
		End If

		BigMap (nPant, scrW * y + x) = d - t0
		dp = d
	Wend

	' Write packed tiles to tempbin
	Print "Writing packed tiles"
	resetPartialBin 
	For i = 0 To (maxPants)-1
		For j = 0 To (scrW*scrH)-1 Step 2
			writeToPartialBin ((BigMap (i, j) And &HF) Shl 4) Or (BigMap (i, j+1) And &HF)
		Next j
	Next i

	' Write decos to tempbin
	decosize = 0
	If sclpGetValue ("nodecos") = "" And decosAre Then
		Print "Writing decos"
		For nPant = 0 To maxPants - 1
			If decosI (nPant) Then
				For i = 0 To decosI (nPant) - 1
					decoT = decos (nPant, i)
					
					If decoT <> &Hff Then
						decoCT = 1
						YX (0) = decosYX (nPant, i)
						' Find more:
						For j = i + 1 To decosI (nPant) - 1
							If decos (nPant, i) = decos (nPant, j) Then
								' Found! DESTROY!
								YX (decoCT) = decosYX (nPant, j)
								decoCT = decoCT + 1
								decos (nPant, j) = &Hff
							End If
						Next j
						If decoCT = 1 Then
							' T | 128, YX
							decosO (nPant, decosOI (nPant)) = decoT Or 128: decosOI (nPant) = decosOI (nPant) + 1
							decosO (nPant, decosOI (nPant)) = YX (0): decosOI (nPant) = decosOI (nPant) + 1
						Else
							' T N YX YX YX YX...
							decosO (nPant, decosOI (nPant)) = decoT: decosOI (nPant) = decosOI (nPant) + 1
							decosO (nPant, decosOI (nPant)) = decoCT: decosOI (nPant) = decosOI (nPant) + 1
							For j = 0 To decoCT - 1
								decosO (nPant, decosOI (nPant)) = YX (j): decosOI (nPant) = decosOI (nPant) + 1
							Next j
						End If
					End If
				Next i
			End If
		Next nPant

		For nPant = 0 To maxPants - 1
			If decosOI (nPant) Then
				decosOffs (nPant) = partialBinIndex
				For i = 0 To decosOI (nPant) - 1
					writeToPartialBin decosO (nPant, i)
					decosize = decosize + 1
				Next i
				writeToPartialBin 0
			Else
				decosOffs (nPant) = 0
			End If
		Next nPant
		
	End If

	' Does it fit?
	If binIndex + partialBinIndex > 8192 Then
		fBin = FreeFile
		Print "Writing binary #" & chrRom
		Open sclpGetValue ("bin") For Binary As #fBin
		writeBin fBin
		Close fBin
		resetBin
		chrRom = chrRom + 1
	End If

	' Copy
	copyPartialBinToMainBin

	Print #fOut, "// Definitions"
	Print #fOut, ""
	Print #fOut, "#define MAP_" & Hex (nMap, 2) & "_CHRROM    " & chrRom
	Print #fOut, "#define MAP_" & Hex (nMap, 2) & "_BASE      0x" & Hex (lBase, 4)
	Print #fOut, "#define MAP_" & Hex (nMap, 2) & "_W         " & mapW
	Print #fOut, "#define MAP_" & Hex (nMap, 2) & "_H         " & mapH
	Print #fOut, "#define MAP_" & Hex (nMap, 2) & "_MAXPANTS  " & (mapW*mapH)
	Print #fOut, ""

	Print #fOut, "// Decorations index"
	Print #fOut, ""
	Print #fOut, "const unsigned int map_" & Hex (nMap, 2) & "_decos_offset [] = {"
	j = 0: first = -1

	For nPant = 0 To maxPants - 1
		If decosOI (nPant) Then
			If first Then first = 0 Else Print #fOut, ", ";
			If j = 2 Then Print #fOut, "": j = 0
			If j = 0 Then Print #fOut, "	";
			Print #fOut, "MAP_" & Hex (nMap, 2) & "_BASE + 0x" & Hex (decosOffs (nPant), 4);
			j = j + 1
		Else
			If first Then first = 0 Else Print #fOut, ", ";
			If j = 2 Then Print #fOut, "": j = 0
			If j = 0 Then Print #fOut, "	";
			Print #fOut, "0                   ";
			j = j + 1
		End If
	Next nPant

	If j then Print #fOut, ""
	Print #fOut, "};"
	Print #fOut, ""
	Print #fOut, "// Total decorations size in bytes is " & decosize
	Print #fOut, ""

	Print "Writing locks"
	lockssize = 0
	If locksI Then
		Print #fOut, "// Locks"
		Print #fOut, "// These tiles are locks: ";
		For i = 0 To tlocksIndex - 1
			Print #fOut, tlocks (i); 
		Next i
		Print #fOut, ""
		Print #fOut, "const unsigned char map_" & Hex (nMap, 2) & "_locks [] = {"
		Print #fOut, "	";

		For i = 0 To locksI - 1
			Print #fOut, "0x" & Lcase (Hex (locks (i), 2));
			If i < locksI - 1 Then Print #fOut, ", ";
			lockssize = lockssize + 1
		Next i
		Print #fOut, ""
		Print #fOut, "};"
		Print #fOut, ""
	End If

	' Update base
	lBase = lBase + partialBinIndex

	Close #fIn

	Print "DONE!"

	nMap = nMap + 1

Wend

Print "Writing binary #" & chrRom
fBin = FreeFile
Open sclpGetValue ("bin") For Binary As #fBin
writeBin fBin
Close fBin

Close fListIn
Close fOut
