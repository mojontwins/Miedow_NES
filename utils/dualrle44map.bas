' dualrle44map.bas v0.1
' fbc rle44map.bas cmdlineparser.bas mtparser.bas

#include "cmdlineparser.bi"
#include "mtparser.bi"

Sub usage 
	Print "usage:"
	Print ""
	Print "dualrle44map.exe in=map.map out=map.h size=W,H prefix=P [tlock=T] [scrsizes]"
	Print "             [scrsize=w,h] [fixmappy]"
	Print "             in is the input filename."
	Print "             out is the output filename."
	Print "             size is the size, in screens."
	Print "             prefix will be appended to labels."
	Print "             tlock is the tile representing locks/bolts"
	Print "             scrsizes prints screen sizes as comments"
	Print "             scrsize is the size of the screen in tiles. Default is 16x12"
	Print "             fixmappy will substract 1 from every byte read"
End Sub

Dim As String mandatory (3) = { "in", "out", "size", "prefix" }
Dim As Integer coords (7), mapW, mapH, scrW, scrH, nPant, maxPants, mapWtiles, fixMappy, realPant
Dim As Integer fIn, fOut, xP, yP, x, y, i, j, tLock, locksI, n, cMapI, ctr, totalBytes, t0, lockssize, screensum
Dim As uByte BigMap (127, 1, 255)
Dim As uByte cMap (127, 255), scrSizes (127)
Dim As String*384 cMapAmalgam (127)
Dim As uByte locks (63)
Dim As uByte d, dp, layer
Dim As uByte scrMaps (127)

Print "dualrle44map v0.1 ";

sclpParseAttrs
If Not sclpCheck (mandatory ()) Then usage: End

parseCoordinatesString sclpGetValue ("size"), coords ()
mapW = coords (0): mapH = coords (1)
maxPants = mapW * mapH

If sclpGetValue ("scrsize") <> "" Then
	parseCoordinatesString sclpGetValue ("scrsize"), coords ()
	scrW = coords (0): scrH = coords (1)
Else 
	scrW = 16: scrH = 12
End If

mapWtiles = mapW * scrW

If sclpGetValue ("tlock") <> "" Then tLock = Val (sclpGetValue ("tlock")) Else tLock = -1

fIn = FreeFile
Open sclpGetValue ("in") For Binary As #fIn
fOut = FreeFile
Open sclpGetValue ("out") For Output As #fOut

Print #fOut, "// " & sclpGetValue ("out") & ", generated by dualrle44map v0.1"
Print #fOut, "// Copyleft 2017 by The Mojon Twins"
Print #fOut, ""
Print #fOut, "// MAP_W = " & mapW & ", MAP_H = " & mapH & " SCR_W = " & scrW & " SCR_H = " & scrH
Print #fOut, ""

Print "Reading ~ ";

fixMappy = (sclpGetValue ("fixmappy") <> ""): If fixMappy Then Print "[fixmappy] ";

i = 0: locksI = 0: dp = 0
While Not Eof (fIn)
	' Read from file
	Get #fIn, , d
	If fixMappy Then d = d - 1
	
	' Screen coordinates
	xP = (i \ scrW) Mod mapW
	yP = i \ (scrW * scrH * mapW)
	
	' Tile coordinates
	x = i Mod scrW
	y = (i \ mapWtiles) Mod scrH
	
	' screen number
	nPant = xp + yp * mapW

	' Next n
	i = i + 1

	' tlock?
	If d = tLock Then
		locks (locksI) = nPant: locksI = locksI + 1
		locks (locksI) = (y Shl 4) Or x: locksI = locksI + 1
	End if

	' Write to layers
	If d < 15 Then
		' d Goes to top layer, dp goes to bottom layer
		BigMap (nPant, 1, scrW*y+x) = d
		BigMap (nPant, 0, scrW*y+x) = dp
	Else
		' d-15 goes to bottom layer, dp updates, 0 goes to top layer
		BigMap (nPant, 1, scrW*y+x) = 0
		BigMap (nPant, 0, scrW*y+x) = d-15
		dp = d
	End If
Wend

Print "Compressing ~ ";
totalBytes = 0
For nPant = 0 To maxPants - 1
	d = BigMap (nPant, layer, 0): n = 1: cMapI = 0
	cMapAmalgam (nPant) = ""
	screensum = 0
	For layer = 0 To 1	
		For i = 1 To scrW*scrH-1
			screensum = screensum + BigMap (nPant, layer, i)
			' Different: write, substitute
			If BigMap (nPant, layer, i) <> d Or n = 16 Then
				cMap (nPant, cMapI) = (d And 15) Or ((n - 1) Shl 4)
				cMapAmalgam (nPant) = cMapAmalgam (nPant) & Hex (cMap (nPant, cMapI), 2)
				cMapI = cMapI + 1
				n = 0
			End If
			d = BigMap (nPant, layer, i): n = n + 1
		Next i
		cMap (nPant, cMapI) = (d And 15) Or ((n - 1) Shl 4)
		cMapAmalgam (nPant) = cMapAmalgam (nPant) & Hex (cMap (nPant, cMapI), 2)
		cMapI = cMapI + 1
	Next layer

	realPant = nPant

	' Detect empty screen
	If screensum = 0 Then 
		realPant = 255: cMapI = 0
	Else
		' Search for repeated screens
		For j = 0 To nPant - 1
			If cMapAmalgam (j) = cMapAmalgam (nPant) Then
				realPant = j
				cMapI = 0
				Exit For
			End If
		Next j
	End If

	scrSizes (nPant) = cMapI
	scrMaps (nPant) = realPant '' Fixe here
	totalBytes = totalBytes + cMapI
Next nPant

Print "Writing ~ ";
For nPant = 0 To maxPants - 1
	If scrMaps (nPant) = 255 Then
		Print #fOut, "// Screen " & Lcase (Hex (nPant, 2)) & " is empty."
	ElseIf scrSizes (nPant) Then
		Print #fOut, "const unsigned char scr_" & sclpGetValue ("prefix") & "_" & Lcase (Hex (nPant, 2)) & " [] = {";
		For i = 0 To scrSizes (nPant) - 1
			Print #fOut, "0x" & Lcase (Hex (cMap (nPant, i), 2));
			If i < scrSizes (nPant) - 1 Then Print #fOut, ", ";
		Next i
		Print #fOut, "};"
		If sclpGetValue ("scrsizes") <> "" Then Print #fOut, "// Size = " & scrSizes (nPant) & " bytes."
	Else
		Print #fOut, "// Screen " & Lcase (Hex (nPant, 2)) & " is a copy of screen " & Lcase (Hex (scrMaps (nPant), 2)) & "."
	End If
Next nPant

' Generate index
Print #fOut, ""
Print #fOut, "const unsigned char * const map_" & sclpGetValue ("prefix") & " [] = {"
ctr = 0
For nPant = 0 To maxPants - 1
	If ctr = 0 Then Print #fOut, "	";
	If scrMaps (nPant) = 255 Then
		Print #fOut, Space (Len ("scr_" & sclpGetValue ("prefix") & "_")) & " 0";
	Else
		Print #fOut, "scr_" & sclpGetValue ("prefix") & "_" & Lcase (Hex (scrMaps (nPant), 2));
	Endif
	If nPant < maxPants - 1 Then Print #fOut, ", ";
	ctr = ctr + 1: If ctr = mapW And nPant < maxPants - 1 Then ctr = 0: Print #fOut, ""
	totalBytes = totalBytes + 2
Next nPant
Print #fOut, ""
Print #fOut, "};"
Print #fOut, ""
Print #fOut, "// Total bytes = " & totalBytes
Print #fOut, ""

' Write locks
lockssize = 0
If locksI Then
	Print #fOut, "const unsigned char map_" & sclpGetValue ("prefix") & "_locks [] = {"
	Print #fOut, "	";
	For i = 0 To locksI - 1
		Print #fOut, "0x" & Lcase (Hex (locks (i), 2));
		If i < locksI - 1 Then Print #fOut, ", ";
		lockssize = lockssize + 1
	Next i
	Print #fOut, ""
	Print #fOut, "};"
	Print #fOut, ""
End If
totalBytes = totalBytes + lockssize

Print #fOut, "// Total map data in bytes is " & totalBytes
Print #fOut, ""

Close #fOut, #fIn


Print "DONE! " & totalBytes & " bytes." 

