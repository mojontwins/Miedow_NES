' rlebytemap 0.1
' fbc rlebytemap.bas cmdlineparser.bas mtparser.bas

#include "cmdlineparser.bi"
#include "mtparser.bi"

Sub usage 
	Print "usage:"
	Print ""
	Print "rlebytemap.exe in=map.map out=map.h size=W,H prefix=P [tlock=T] [scrsizes]"
	Print "               [scrsize=w,h] [fixmappy]"
	Print "           in is the input filename."
	Print "           out is the output filename."
	Print "           size is the size, in screens."
	Print "           prefix will be appended to labels."
	Print "           tlock is the tile representing locks/bolts"
	Print "           scrsizes prints screen sizes as comments"
	Print "           scrsize is the size of the screen in tiles. Default is 16x12"
	Print "           fixmappy will substract 1 from every byte read"
End Sub

Dim As String mandatory (3) = { "in", "out", "size", "prefix" }
Dim As Integer coords (7), mapW, mapH, scrW, scrH, nPant, maxPants, mapWtiles, fixMappy, realPant
Dim As Integer fIn, fOut, xP, yP, x, y, i, j, tLock, locksI, n, cMapI, ctr, totalBytes
Dim As uByte BigMap (127, 255)
Dim As uByte cMap (127, 255), scrSizes (127)
Dim As String cMapAmalgam (127)
Dim As uByte locks (63)
Dim As uByte d
Dim As uByte scrMaps (127)

Print "rlebytemap v0.1 ";
sclpParseAttrs
If Not sclpCheck (mandatory ()) Then usage: End

parseCoordinatesString sclpGetValue ("size"), coords ()
mapW = coords (0): mapH = coords (1)
maxPants = mapW * mapH

If sclpGetValue ("scrsize") <> "" Then
	parseCoordinatesString sclpGetValue ("scrsize"), coords ()
	scrW = coords (0): scrH = coords (1)
Else 
	scrW = 16: scrH = 12
End If

mapWtiles = mapW * scrW

If sclpGetValue ("tlock") <> "" Then tLock = Val (sclpGetValue ("tlock")) Else tLock = -1

fIn = FreeFile
Open sclpGetValue ("in") For Binary As #fIn
fOut = FreeFile
Open sclpGetValue ("out") For Output As #fOut

Print #fOut, "// " & sclpGetValue ("out") & ", generated by rlebytemap v0.1"
Print #fOut, "// Copyleft 2016 by The Mojon Twins"
Print #fOut, ""
Print #fOut, "// MAP_W = " & mapW & ", MAP_H = " & mapH & " SCR_W = " & scrW & " SCR_H = " & scrH
Print #fOut, ""

Print "Reading ... ";

fixMappy = (sclpGetValue ("fixmappy") <> ""): If fixMappy Then Print "[fixmappy] ";

i = 0: locksI = 0
While Not Eof (fIn)
	' Read from file
	Get #fIn, , d
	If fixMappy Then d = d - 1
	
	' Screen coordinates
	xP = (i \ scrW) Mod mapW
	yP = i \ (scrW * scrH * mapW)
	
	' Tile coordinates
	x = i Mod scrW
	y = (i \ mapWtiles) Mod scrH
	
	' screen number
	nPant = xp + yp * mapW

	' Next n
	i = i + 1

	' tlock?
	If d = tLock Then
		locks (locksI) = nPant: locksI = locksI + 1
		locks (locksI) = (y Shl 4) Or x: locksI = locksI + 1
	End if

	' Write
	BigMap (nPant, scrW * y + x) = d
Wend

Print "Compressing ... ";
totalBytes = 0
For nPant = 0 To maxPants - 1
	d = BigMap (nPant, 0): n = 1: cMapI = 0
	cMapAmalgam (nPant) = ""
	For i = 1 To scrW*scrH-1
		' Different: write, substitute
		If BigMap (nPant, i) <> d Then
			If n = 1 Then
				cMap (nPant, cMapI) = d: cMapI = cMapI + 1
				cMapAmalgam (nPant) = cMapAmalgam (nPant) & Hex (d, 2)
			Else
				cMap (nPant, cMapI) = d Or 128: cMapI = cMapI + 1
				cMapAmalgam (nPant) = cMapAmalgam (nPant) & Hex (d Or 128, 2)
				cMap (nPant, cMapI) = n: cMapI = cMapI + 1
				cMapAmalgam (nPant) = cMapAmalgam (nPant) & Hex (n, 2)
			End If
			n = 0
		End If
		d = BigMap (nPant, i): n = n + 1
	Next i
	
	' Write last
	If n = 1 Then
		cMap (nPant, cMapI) = d: cMapI = cMapI + 1
	Else
		cMap (nPant, cMapI) = d Or 128: cMapI = cMapI + 1
		cMap (nPant, cMapI) = n: cMapI = cMapI + 1
	End If

	realPant = nPant

	' Search for repeated screens
	For j = 0 To nPant - 1
		If cMapAmalgam (j) = cMapAmalgam (nPant) Then
			realPant = j
			cMapI = 0
			Exit For
		End If
	Next j

	scrSizes (nPant) = cMapI
	scrMaps (nPant) = realPant '' Fixe here
	totalBytes = totalBytes + cMapI
Next nPant

Print "Writing ... ";
For nPant = 0 To maxPants - 1
	If scrSizes (nPant) Then
		Print #fOut, "const unsigned char scr_" & sclpGetValue ("prefix") & "_" & Lcase (Hex (nPant, 2)) & " [] = {";
		For i = 0 To scrSizes (nPant) - 1
			Print #fOut, "0x" & Lcase (Hex (cMap (nPant, i), 2));
			If i < scrSizes (nPant) - 1 Then Print #fOut, ", ";
		Next i
		Print #fOut, "};"
		If sclpGetValue ("scrsizes") <> "" Then Print #fOut, "// Size = " & scrSizes (nPant) & " bytes."
	Else
		Print #fOut, "// Screen " & Lcase (Hex (nPant, 2)) & " is a copy of screen " & Lcase (Hex (scrMaps (nPant), 2)) & "."
	End If
Next nPant

' Generate index
Print #fOut, ""
Print #fOut, "const unsigned char * const map_" & sclpGetValue ("prefix") & " [] = {"
ctr = 0
For nPant = 0 To maxPants - 1
	If ctr = 0 Then Print #fOut, "	";
	Print #fOut, "scr_" & sclpGetValue ("prefix") & "_" & Lcase (Hex (scrMaps (nPant), 2));
	If nPant < maxPants - 1 Then Print #fOut, ", ";
	ctr = (ctr + 1) And 7: If ctr = 0 And nPant < maxPants - 1 Then Print #fOut, ""
	totalBytes = totalBytes + 2
Next nPant
Print #fOut, ""
Print #fOut, "};"
Print #fOut, ""
Print #fOut, "// Total bytes = " & totalBytes
Print #fOut, ""

' Write locks
If locksI Then
	Print #fOut, "const unsigned char map_" & sclpGetValue ("prefix") & "_locks [] = {"
	Print #fOut, "	";
	For i = 0 To locksI - 1
		Print #fOut, "0x" & Lcase (Hex (locks (i), 2));
		If i < locksI - 1 Then Print #fOut, ", ";
	Next i
	Print #fOut, ""
	Print #fOut, "};"
	Print #fOut, ""
End If

Close #fOut, #fIn


Print "DONE! " & totalBytes & " bytes." 
